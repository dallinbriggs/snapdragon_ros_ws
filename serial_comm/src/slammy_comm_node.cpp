/************************************************************
 * 
 * Slammy Comm Node
 * 
 * This node receives serial packets from another node (snappy comm node
 * for instance).  It parses the packets and publishes the data as a 
 * rostopic.  For now, it will simply publish pose generated by the 
 * vislam algorithm on the snapdragon flight.  
 * 
 * Author: Neil Johnson
 * Date: 1/16/18
 ************************************************************/
#include <ros/ros.h>
#include <geometry_msgs/PoseStamped.h>
#include "SerialPort/SerialPortLinux.h"

//#define SERIAL_DEVICE "/dev/snappy"
#define SERIAL_DEVICE "/dev/ttyUSB0"
#define SERIAL_BAUD B115200
//#define SERIAL_BAUD B921600

#define DEBUG_SERIAL_RX 1

class SlammyComm {
	
public:
    SlammyComm(const ros::Publisher &posePub) :
		m_posePub(posePub)
    {
		m_serialPort.Open(SERIAL_DEVICE, SERIAL_BAUD, PARITY_NONE);
		ublen = 0;
	}
	
    ~SlammyComm() 
    {
		disconnect();
	}
	
    void disconnect()
    {
		m_serialPort.Close();
	}
	
	#define PACKET_LENGTH 74
	
	#define PACKET_TYPE_POSE_STAMPED 101
	
	#define MAX_BYTES 1024
	
	#define MIN_PKT_SIZE 74
	
	//! Process Bytes:
	void processBytes()
	{
		//! Read some bytes, but never allow the unprocessed array to get bigger than MAX_BYTES:
		int temp = m_serialPort.readBytes(&ub[ublen], MAX_BYTES - ublen);
		if (temp < 0) {
			switch(errno) 
			{
				case EAGAIN:
					//printf("No big deal...EAGAIN\n");
					break;
				default:
					printf("something went wrong with read(): %s (%d)\n", strerror(errno), errno);			
					break;
			}
			
			return;
		}
		
		ublen += temp;
		
		int bytes_processed = 0;
		if (ublen >= MIN_PKT_SIZE) {
			//! There's enough bytes to make up a packet.  Check for a packet:
			bytes_processed = FindPackets();
		}		
		
		if (bytes_processed == 0) {	
			return;
		}
		
		//! Copy any bytes that haven't been processed to the beginning of ub array:
		if (ublen > bytes_processed) {
			memcpy(&ub[0], &ub[bytes_processed], ublen - bytes_processed);
			#if DEBUG_SERIAL_RX
			printf("  processed %d bytes, copying %d bytes to front of buffer (ublen: %d)\n", bytes_processed, ublen - bytes_processed, ublen);
			#endif
		} 
		ublen -= bytes_processed;
		
		#if DEBUG_SERIAL_RX
		if (ublen != 0) {
			printf("Bytes remaining after processing packets: %d\n", ublen);
		}
		#endif
	}
	
	int FindPackets()
	{
		int i=0;
		//! Find the start_bytes
		for (i=0; i<ublen - MIN_PKT_SIZE + 1; i++) {
			if ((ub[i] == 0xAA) && (ub[i+1] == 0xBB))
			{				
				//! Get packet length:
				uint16_t pkt_len;
				memcpy(&pkt_len, &ub[i+2], 2);
				
				//! If we decide to use this packet parsing code for more than just pose, this needs to be rewritten.
				//! But for now, the pkt_len acts basically as more start bytes:
				if (pkt_len != PACKET_LENGTH) {
					printf("We got the right start bytes, but the packet size is invalid! (%d)\n",
						pkt_len);
					continue;
				}			
				
				//! If we got here, the pkt_len is right.  Check the checksum.
				uint8_t checksum_byte = ub[i+PACKET_LENGTH-1];
				uint8_t mychecksum = computeChecksum(&ub[i],PACKET_LENGTH-1);
				
				if (mychecksum != checksum_byte) {
					printf("Checksum failure! Mine: %d, Packet's: %d\n", mychecksum, checksum_byte);
					continue;
				}	
				
				//! If we got here, the packet is valid.  Process It!
				if (ProcessPacket(&ub[i], PACKET_LENGTH)) {
					i += PACKET_LENGTH - 1;
				}
			}						
		}
		return i;	
	}
	
	bool ProcessPacket(uint8_t *packet, int len) {
		
		if (packet[4] != PACKET_TYPE_POSE_STAMPED) {
			ROS_ERROR("ProcessPacket type is not supported!  %d", packet[4]);
			return false;
		}
		
		if (len < PACKET_LENGTH) {
			ROS_ERROR("ProcessPacket: packet is too short!  %d", len);
			return false;
		}
		
		geometry_msgs::PoseStamped msg;
		memcpy(&msg.header.seq, &packet[5], 4);
		memcpy(&msg.header.stamp.sec, &packet[9], 4);
		memcpy(&msg.header.stamp.nsec, &packet[13], 4);
		
		memcpy(&msg.pose.position.x, &packet[17], 8);
		memcpy(&msg.pose.position.y, &packet[25], 8);
		memcpy(&msg.pose.position.z, &packet[33], 8);
				
		//! Orientation:
		memcpy(&msg.pose.orientation.x, &packet[41], 8);
		memcpy(&msg.pose.orientation.y, &packet[49], 8);
		memcpy(&msg.pose.orientation.z, &packet[57], 8);
		memcpy(&msg.pose.orientation.w, &packet[65], 8);
		
		#if DEBUG_SERIAL_RX
		printf("Got Valid Packet: Seq: %d\n", msg.header.seq);
		printf("  position: %f %f %f\n", msg.pose.position.x, msg.pose.position.y, msg.pose.position.z);
		printf("  orientation: %f %f %f %f\n", msg.pose.orientation.x, msg.pose.orientation.y, msg.pose.orientation.z, msg.pose.orientation.w);
		#endif
		
		m_posePub.publish(msg);		
		return true;
	}
	
	uint8_t computeChecksum(uint8_t *pkt, int len)
	{
		uint8_t c = 0;
		for (int i=0; i<len; i++) {
			c ^= pkt[i];
		}
		
		return c;
	}

private:
    SerialPortLinux m_serialPort;
    ros::Publisher m_posePub;
    
    //! Unprocessed Byte Array:
    uint8_t ub[MAX_BYTES];
    uint32_t ublen;
};

int main(int argc, char **argv)
{
	ros::init(argc, argv, "slammy_comm");
	ros::NodeHandle nh;
	
	ros::Publisher posePub = nh.advertise<geometry_msgs::PoseStamped>("/snappy/pose", 1);
	
	SlammyComm comm(posePub);
	
	ros::Rate loop_rate(100);
	
	while (ros::ok())
	{
		comm.processBytes();
		ros::spinOnce();
		loop_rate.sleep();
	}
		
	return 0;	
}
